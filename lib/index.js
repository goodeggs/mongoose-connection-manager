// Generated by CoffeeScript 1.7.1
(function() {
  var ConnectionStates, databases, mongoose;

  mongoose = require('mongoose');

  ConnectionStates = {
    disconnected: 0,
    connected: 1,
    connecting: 2,
    disconnecting: 3
  };

  module.exports = databases = {
    connections: {},
    callbacks: [],
    get: function(name) {
      return this.connections[name];
    },
    exists: function(name) {
      return this.connections[name] != null;
    },
    create: function(name, settings) {
      if (name == null) {
        throw new Error("Connection name must be provided");
      }
      if (settings == null) {
        throw new Error("Connection settings must be provided");
      }
      if (!settings.url) {
        throw new Error("Connection url must be provided");
      }
      if (settings.useDefault) {
        this.connections[name] = mongoose.connection;
      } else {
        this.connections[name] = mongoose.createConnection();
      }
      this.connections[name].settings = settings;
      return this.connections[name];
    },
    connect: function(cb) {
      var connectTo, connection, name, _ref, _results;
      if (this.allConnected()) {
        return process.nextTick(cb);
      }
      if (cb != null) {
        this.callbacks.push(cb);
      }
      connectTo = (function(_this) {
        return function(name, settings) {
          var finishOrRetry, options, url;
          url = settings.url;
          options = settings.options;
          finishOrRetry = function(err, result) {
            var callback, _ref, _results;
            if (err != null) {
              if ((_ref = settings.logger) != null) {
                _ref.error(err, "Failed to connect to `" + url + "` on startup - retrying in 5 sec");
              }
              return setTimeout((function() {
                return connectTo(name, settings);
              }), 5000);
            } else if (_this.allConnected()) {
              _results = [];
              while (callback = _this.callbacks.pop()) {
                _results.push(callback());
              }
              return _results;
            }
          };
          if (url.indexOf(',') >= 0) {
            return _this.connections[name].openSet(url, options, finishOrRetry);
          } else {
            return _this.connections[name].open(url, options, finishOrRetry);
          }
        };
      })(this);
      _ref = this.connections;
      _results = [];
      for (name in _ref) {
        connection = _ref[name];
        switch (connection.readyState) {
          case ConnectionStates.disconnected:
            _results.push(connectTo(name, connection.settings));
            break;
          case ConnectionStates.disconnecting:
            throw new Error("Called connect() before disconnect() has finished");
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    },
    allConnected: function() {
      return Object.keys(this.connections).every((function(_this) {
        return function(connection) {
          return _this.connections[connection].readyState === ConnectionStates.connected;
        };
      })(this));
    },
    disconnect: function(callback) {
      return mongoose.disconnect(callback);
    }
  };

}).call(this);
